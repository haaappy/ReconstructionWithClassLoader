{"name":"Reconstructionwithclassloader","tagline":"Extend hot deployment of JBoss5, dependency reconstruction with class loaders","body":"# 依赖修复在应用服务器上的集成\r\n\r\n## Jboss5.1.0调试环境搭建\r\n\r\n### 环境\r\n\r\n* Linux操作系统\r\n* java version \"1.6.0_24\"\r\n* Eclipse IDE for Java EE Developers  [下载地址](http://eclipse.org/downloads/?osType=linux)\r\n* Jboss可执行版本5.1.0  [下载地址](http://www.jboss.org/jbossas/downloads)\r\n\r\n### 源代码获取\r\n从Eclipse的SVN中获取Jboss5.1.0的源代码：[方法链接](http://blog.csdn.net/sunguangran/article/details/6707650)\r\n\r\n获得的源代码是不完整的，并且是通过POM文件组织的。需要在命令行中用Maven工具进行构建——\"mvn install\"，但是源代码中的pom.xml文件缺少一些依赖，执行会报错，需要找到这些缺少的依赖所在的库，并在pom.xml中添加。[链接](http://www.mkyong.com/maven/how-to-add-remote-repository-in-maven-pom-xml/)\r\n\r\n还一有一种直接运行源代码中build文件夹下build.sh的方法，同样需要在顶层的pom.xml文件中的<pluginRepositories>下添加插件库：\r\n\r\n    <pluginRepository>\r\n\r\n        <id>repo.grails.org</id>\r\n\r\n        <name>JBoss Plugin Repo</name>\r\n\r\n        <url>http://repo.grails.org/grails/libs-releases</url>\r\n\r\n        <releases>\r\n\r\n            <enabled>true</enabled>\r\n\r\n        </releases>\r\n\r\n        <snapshots>\r\n\r\n            <enabled>true</enabled>\r\n\r\n        </snapshots>\r\n\r\n    </pluginRepository>\r\n\r\n\r\n即可运行build.sh，并且这个build过程包含了maven过程，会在相应子项目中生成target文件夹及output文件夹，build文件夹下的output中的jboss-5.1.0.GA就是由源代码生成的可执行版本的Jboss5.1.0。同时在主目录会生成.m的隐藏文件夹（Ctrl+H显示），里面都是构建的工程时发现所缺失的源代码，并从远程库中下载下来，存放在.m2中。至此，所有的源代码均已经找到。\r\n\r\n### 调试环境搭建\r\n\r\n建立Java Project,将可执行版本的jboss-5.1.0放入项目中，并将其bin,lib,common->lib,server->all下的所有JAR包设置为Java Project的build path，项目启动的入口是bin下run.jar中Main方法。此时可以通过设置为build path的JAR包中的.class文件进行断点运行察看，并不能修改源代码。这一过程需要将/home/happy/JBOSS/jboss-5.1.0.GA-src/build/output/jboss-5.1.0.GA/server/all/deployers/jbossweb.deployer/web.xml放入src文件夹，否则会报错。修改源代码的时候将找到的代码包解压，并设置为代码文件夹，放在Java Project下即可。运行时，新的.java文件或编译成.class文件放入bin中，重新将bin中的.class对应打包成JAR文件，替换原版本的Jboss的JAR文件即可。\r\n\r\n### 数据库相关配置\r\n\r\n实体Bean需要安装数据库，选用MySql5.5;\r\n在写实体Bean所需要的配置文件、驱动Jar包已经上传。详细说明参见教程中[第六章](http://wenku.baidu.com/view/af87f8c50c22590102029d88.html)\r\n安装的数据库需要有个名为aejb_test的数据库，用户名为root，密码为123456。\r\n\r\n## 应用服务器层面的依赖修复\r\n\r\n### SessionBean->EntityBean反向依赖重部署功能的实现\r\n\r\n* 需要修改的源码\r\n    jboss-deployers-impl.jar中org.jboss.deployers.plugins.deployers下的DeployersImpl.java\r\n    jboss-ejb3-core.jar中的org.jboss.injection下的PcEncInjector.java\r\n\r\n* 部署流程\r\n    DeployersImpl.java中是部署的主要流程。每个Bean部署时都会多次执行这部分的代码，因为部署的时候有多个阶段(stageName)，每个阶段都会执行一次install方法。其中install方法中的deploymentContext变量中记录了部署所需要的信息，随着部署阶段一步步的执行下去，它的内容会不断扩充。最后一个Installed阶段执行后，可以认为这个Bean已经部署完成。\r\n\r\n* 依赖关系\r\n    PcEncInjector.java中的inject方法注入了SessionBean依赖EntityBean的关系，我们在这部分通过JNDI加入关系的映射表aejbConMap，key为SessionBean的路径，value为所依赖的单元名称的集合。\r\n* 反向查找\r\n    在deployersImpl.java的install方法中，部署的最后一个Installed阶段,通过deploymentContext中的component字段来找在aejbConMap中是否有对应的value所含元素，反向查到被依赖的SessionBean的路径。\r\n\r\n* 重新部署\r\n   调用外部的命令行touch命令，对sessionBean进行重新部署。\r\n\r\n### SessionBean->SessionBean反向依赖重部署功能的实现\r\n\r\n* 需要修改的源码\r\n    jboss-ejb3-core.jar中的org.jboss.ejb下的EJBContainer.java\r\n    jboss-ejb3-core.jar中的org.jboss.injection下的EjbEncInjector.java\r\n\r\n* 部署流程\r\n    同SessionBean->EntityBean。\r\n\r\n* 依赖关系\r\n    EjbEncInjector.java中的inject方法注入了SessionBean依赖SessionBean的关系，我们在这部分通过JNDI加入关系的映射表aejbConMap，key为SessionBean的路径，value为所依赖的接口名称的集合。\r\n\r\n* 反向查找\r\n    在EJBContainer.java的start方法中的最后阶段，通过容器中的getBusinessInterfaces()查找在aejbConMap中是否有对应的value所含元素，反向查到被依赖的SessionBean的路径。（与SessionBean->EntityBean不同的是，接口信息只能在Container中找到，所以无法在DeployersImpl中进行）\r\n\r\n* 重新部署\r\n   调用外部的命令行touch命令，对sessionBean进行重新部署。\r\n\r\n\r\n### 生成新的可执行版本\r\n\r\n参照所要修改的Jar文件，将这个Jar包按原来的文件组织重新打包，并替换，即可执行。\r\n\r\n### 参考资料\r\n\r\n#### JBoss部署流程\r\n\r\norg.jboss.deployment.scanner.URLDeploymentScanner负责热部署的执行。它作为一个MBean，在JBoss启动时被创建。JBoss启动时，会调用它的createService方法。该方法又会其父类AbstractDeploymentScanner的createService方法。其父亲的createService方法会创建一个ScannerThread线程，这个线程每隔一段时间就会调用URLDeploymentScanner的scan方法。scan方法的工作就是检查deploy目录下的变化，并调用MainDeployer的相应方法来进行重新部署、销毁等操作。\r\n\r\nMainDeployer将为部署单元查找能够部署它的SubDeployer。例如，MainDeployer会为EJB组件找到EJBDeployer。所有的SubDeployer同MainDeployer一样，都是在JBoss启动时创建的。而且，每个SubDeployer都被注册到MainDeployer中，这样MainDeloyer就能找到它们。\r\n\r\n接着，MainDeployer将部署单元添加到部署等待队列中。这个队列的作用是，如果某个部署单元因为依赖关系不满足，而不能被部署，则将它暂存起来。但依赖关系满足时，MainDeployer就可以从等待队列中将它取出，并重新部署。再接着，MainDeployer将调用部署单元的SubDeployer的init方法，进行特定于组件类型的初始化工作。然后MainDeployer为部署单元创建一个统一类加载器UCL，这个与JBoss的类加载器架构有关。\r\n\r\n[详细部署流程链接](http://www.myexception.cn/operating-system/770304.html)\r\n\r\n#### JBoss类加载机制\r\n\r\nJboss实现了自己的类装载器UnifiedClassLoader3，它继承了标准的java.net.URLClassLoader，覆盖了标准的parent delegation模型以使用共享class和资源仓库（respository）org.jboss.mx.loading.UnifiedLoaderRepository3。一般来说，一个顶层的deployment就有一个UnifiedClassLoader3实例为之工作。一个deployment所装载的类，其他deployment是可见的，全局唯一的UnifiedLoaderRepository3实例用于管理这些类，以及装载它们的UnifieClassLoader3实例。UnifiedLoaderRepository3实例和UnifieClassLoader3实例是一对多的关系。\r\n\r\n追溯Jboss5.1.0的源码，jboss-classloader.jar、boss-classloading-spi.jar、jboss-classloading-vfs.jar和jboss-classloading.jar中就有Jboss中自定义的类加载器。EJB包中用到的类都是由jboss的org.jboss.mx.loading.UnifiedClassLoader3来加载的。\r\n\r\n## 类加载器层面的依赖修复\r\n\r\n### 集成设计\r\n\r\n我们仍然选择JBossAS 5.1进行类加载器层的依赖修复技术的集成。这次的依赖修复是在类加载器层面，依赖关系将在加载过程中获得。从应用服务器层上的依赖修复过程中，我们可以将部署过程进行动态管理方式的扩展，并引入新的具有依赖管理功能的类加载器。\r\n\r\n### 集成实现\r\n\r\n* 需要修改的源码\r\n    jboss-deployers-impl.jar中org.jboss.deployers.plugins.deployers下的DeployersImpl.java\r\n    jboss-classloader.jar中的org.jboss.classloader.spi.base下的BaseClassLoader.java\r\n\r\n* 类加载器\r\n    JBossAS 5.1.0中，负责对部署单元加载的类加载器名为BaseClassLoader。类加载器层面上的依赖修复需要类加载器对依赖进行管理，换句话说，在类加载的过程中需要构建依赖关系图。在这个类加载器中，我们需要增加两个重要的数据结构：reverseDepList和dependencyClassMap。其中，reverseDepList记录了当前的类加载器被哪些类加载器所依赖，类似于在应用服务器层面上依赖修复技术中的反向依赖映射表。同理，dependencyClassMap是一个Map，它的Key是String类型的类名称，Value是BaseClassLoader类型的该类所依赖的类加载器。由于类之间的引用关系，需要其它模块的类加载器的辅助加载，我们通过dependencyClassMap来记录当前的类中所依赖的其它类加载器。\r\n\r\n* 部署流程\r\n    JBossAS 5.1.0的部署流程主要是由DeployerImpl类实现的，这个类的process方法就是部署的主要过程。在依赖修复技术中，依赖由类加载器来维护，但是我们需要部署流程的某一阶段触发重新部署达到修复的目的。根据部署规范，部署是一个典型的三段过程：配置阶段、分发阶段和执行阶段。部署单元的上下文环境在配置阶段中被创建，并且在重部署过程中它们的上下文环境没有发生改变。分发阶段用来负责装载模块并加载类。我们可以在分发阶段前使用原有的上下文环境信息，仅仅更新它的模块类加载器。所以，在修复依赖的重部署过程中节省了创建并设置部署单元环境上下文的时间。在部署流程的扩展上，我们使用classLoaderContextMap 来记录类加载器和部署单元环境上下文\r\n的映射关系，使用reconstructionSet来获得所有受到更新影响的部署单元。最后在process方法的配置阶段之后分发阶段之前，执行依赖模块的更新类加载器并重部署的过程。","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}